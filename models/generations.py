from typing import Dict, Generic, List, TypeVar
from pydantic import BaseModel

from models.keywords import ActorId, ItemId, LocationId
from models.observables import ObservableAction, ObservableActorEntity, ObservableActorState, ObservableEvent, ObservableItemEntity, ObservableItemState, ObservableLocationEntity, ObservableLocationState, ObservableOutcome, ObservableState


class Generatable(BaseModel):
    pass

KEY_TYPE = TypeVar("KEY_TYPE")
VALUE_TYPE = TypeVar("VALUE_TYPE")
class GeneratableTuple(Generatable, Generic[KEY_TYPE,VALUE_TYPE]):
    key: KEY_TYPE
    value: VALUE_TYPE

class GeneratableHash:
    def to_dict(generatable_dict: List[GeneratableTuple[KEY_TYPE,VALUE_TYPE]]) -> Dict[KEY_TYPE,VALUE_TYPE]:
        return {x.key: x.value for x in generatable_dict}


class ActorStateTuple(GeneratableTuple[ActorId,ObservableActorState]):
    pass

class LocationStateTuple(GeneratableTuple[LocationId,ObservableLocationState]):
    pass

class ItemStateTuple(GeneratableTuple[ItemId,ObservableItemState]):
    pass

class ActorAgentGeneration(Generatable):
    """
    The output generated by an actor agent. 
    Actors observe facts about their environment, episode, and character, the generate facts about their character's responses and actions,
    as well as specify any resultant changes in the observable state to actors, locations, or items.
    """

    """Facts representing the outcomes of actions targeting this character. There should be at most one outcome for each action."""
    resulting_outcomes: List[ObservableOutcome]

    """Facts representing the responses and actions taken by the character. This should be limited to a reasonable amount of activity
    can be accomplished in a 10 second span."""
    resulting_actions: List[ObservableAction]

    """Facts representing any triggered events that may occur due to interaction with an item or location."""
    resulting_events: List[ObservableEvent]

    """Any changes in characters' observable state resulting from resulting_outcomes, resulting_actions, or resulting_events"""
    new_actor_states: List[ActorStateTuple]

    """Any changes in items' observable state resulting from resulting_outcomes, resulting_actions, or resulting_events"""
    new_item_states: List[ItemStateTuple]

    """Any changes in locations' observable state resulting from resulting_outcomes, resulting_actions, or resulting_events"""
    new_location_states: List[LocationStateTuple]


class ActionMapTuple(GeneratableTuple[ActorId, List[ObservableEvent | ObservableAction]]):
    pass

class GeneratableEpisode(Generatable):
    """
    An ongoing interaction between multiple actors.
    The primary game loop revolves around playing out a episode by 
    prompting each actor to respond to the conditions of the episode until resolution
    """

    """actors involved in this episode"""
    actor_ids: List[ActorId]

    """a list of the sequence of events that occurred in this episode, ordered from oldest to most recent"""
    event_history: List[ObservableEvent | ObservableAction | ObservableOutcome]

    """a dictionary of queued actions and events that are pending resolution when their targets' agents next act"""
    actor_action_queues: List[ActionMapTuple]

class GameWorldBuilderAgentGeneration(Generatable):
    """
    The central state container for game world entities and events.
    This is the game world that persists across and beyond multiple episodes
    """

    """the locations within this game world"""
    locations: List[ObservableLocationEntity]

    """the actors within this game world"""
    actors: List[ObservableActorEntity]

    """the items within this game world"""
    items: List[ObservableItemEntity]

    """the active episodes within this game world"""
    active_episodes: List[GeneratableEpisode]


